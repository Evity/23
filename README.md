# Software Design Pattern



- Data Structure
- Algorithm
- **Design Pattern**
- Structure Design
- Software Engineer

> In [software engineering](https://en.wikipedia.org/wiki/Software_engineering), a **software design pattern** is a general, [reusable](https://en.wikipedia.org/wiki/Reusability) solution to a commonly occurring problem within a given context in [software design](https://en.wikipedia.org/wiki/Software_design). It is not a finished design that can be transformed directly into [source](https://en.wikipedia.org/wiki/Source_code) or [machine code](https://en.wikipedia.org/wiki/Machine_code). Rather, it is a description or template for how to solve a problem that can be used in many different situations. Design patterns are  formalized [best practices](https://en.wikipedia.org/wiki/Best_practice) that the programmer can use to solve common problems when designing an application or system.
>
> [Object-oriented](https://en.wikipedia.org/wiki/Object-oriented) design patterns typically show relationships and [interactions](https://en.wikipedia.org/wiki/Interaction) between [classes](https://en.wikipedia.org/wiki/Class_(computer_science)) or [objects](https://en.wikipedia.org/wiki/Object_(computer_science)), without specifying the final application classes or objects that are  involved. Patterns that imply mutable state may be unsuited for [functional programming](https://en.wikipedia.org/wiki/Functional_programming) languages. Some patterns can be rendered unnecessary in languages that  have built-in support for solving the problem they are trying to solve,  and object-oriented patterns are not necessarily suitable for  non-object-oriented languages.
>
> Design patterns may be viewed as a structured approach to [computer programming](https://en.wikipedia.org/wiki/Computer_programming) intermediate between the levels of a [programming paradigm](https://en.wikipedia.org/wiki/Programming_paradigm) and a concrete [algorithm](https://en.wikipedia.org/wiki/Algorithm).

*In book *[Design Patterns](https://en.wikipedia.org/wiki/Design_Patterns_(book))* there are 23 patterns in total*

**Polymorphism is the key**

|                   Patterns Classification                    | Name                                                         |                            Stars                             | Effect                                                       |
| :----------------------------------------------------------: | :----------------------------------------------------------- | :----------------------------------------------------------: | ------------------------------------------------------------ |
|                   Creational Pattern（6）                    | [Factory method](https://en.wikipedia.org/wiki/Factory_method_pattern) |                            ★★★★★                             | Define an interface for creating a *single* object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses. |
|                                                              | [Abstract factory](https://en.wikipedia.org/wiki/Abstract_factory_pattern) |                            ★★★★★                             | Provide an interface for creating *families* of related or dependent objects without specifying their concrete classes |
|                                                              | [Singleton](https://en.wikipedia.org/wiki/Singleton_pattern) |                            ★★★★☆                             | Ensure a class has only one instance, and provide a global point of access to it. |
|                          (the 24th)                          | Simple Factory                                               |                            ★★★☆☆                             | Define a class to create instance for other classes, those instances shares the same parent class in usual. |
|                                                              | [Prototype](https://en.wikipedia.org/wiki/Prototype_pattern) |                            ★★★☆☆                             | Specify the kinds of objects to create using a prototypical instance,  and create new objects from the 'skeleton' of an existing object, thus  boosting performance and keeping memory footprints to a minimum. |
|                                                              | [Builder](https://en.wikipedia.org/wiki/Builder_pattern)     |                            ★★☆☆☆                             | Separate the construction of a complex object from its representation,  allowing the same construction process to create various  representations. |
|                                                              | [Dependency Injection](https://en.wikipedia.org/wiki/Dependency_injection) |                                                              | A class accepts the objects it requires from an injector instead of creating the objects directly. |
|                                                              | [Lazy initialization](https://en.wikipedia.org/wiki/Lazy_initialization) |                            PoEAA                             | Tactic of delaying the creation of an object, the calculation of a  value, or some other expensive process until the first time it is  needed. This pattern appears in the GoF catalog as "virtual proxy", an  implementation strategy for the [Proxy](https://en.wikipedia.org/wiki/Proxy_pattern) pattern. |
|                                                              | [Multiton](https://en.wikipedia.org/wiki/Multiton_pattern)   |                                                              | Ensure a class has only named instances, and provide a global point of access to them. |
|                                                              | [Object pool](https://en.wikipedia.org/wiki/Object_pool_pattern) |                                                              | Avoid expensive acquisition and release of resources by recycling  objects that are no longer in use. Can be considered a generalisation of [connection pool](https://en.wikipedia.org/wiki/Connection_pool) and [thread pool](https://en.wikipedia.org/wiki/Thread_pool) patterns. |
|                                                              | [Resource acquisition is initialization](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) (RAII) |                                                              | Ensure that resources are properly released by tying them to the lifespan of suitable objects. |
|                   Structural Pattern（7）                    | [Facade](https://en.wikipedia.org/wiki/Facade_pattern)       |                            ★★★★★                             | Provide a unified interface to a set of interfaces in a subsystem.  Facade defines a higher-level interface that makes the subsystem easier  to use. |
|                                                              | [Adapter](https://en.wikipedia.org/wiki/Adapter_pattern), Wrapper, or Translator |                            ★★★★☆                             | Convert the interface of a class into another interface clients expect.  An adapter lets classes work together that could not otherwise because  of incompatible interfaces. The enterprise integration pattern  equivalent is the translator. |
|                                                              | [Proxy](https://en.wikipedia.org/wiki/Proxy_pattern)         |                            ★★★★☆                             | Provide a surrogate or placeholder for another object to control access to it. |
|                                                              | [Bridge](https://en.wikipedia.org/wiki/Bridge_pattern)       |                            ★★★☆☆                             | Decouple an abstraction from its implementation allowing the two to vary independently. |
|                                                              | [Decorator](https://en.wikipedia.org/wiki/Decorator_pattern) |                            ★★★☆☆                             | Attach additional responsibilities to an object dynamically keeping the  same interface. Decorators provide a flexible alternative to subclassing for extending functionality. |
|                                                              | [Composite](https://en.wikipedia.org/wiki/Composite_pattern) |                            ★★☆☆☆                             | Compose objects into tree structures to represent part-whole  hierarchies. Composite lets clients treat individual objects and  compositions of objects uniformly. |
|                                                              | [Flyweight](https://en.wikipedia.org/wiki/Flyweight_pattern) |                            ★☆☆☆☆                             | Use sharing to support large numbers of similar objects efficiently. |
|                                                              | Extension object                                             |                                                              | Adding functionality to a hierarchy without changing the hierarchy. |
|                                                              | [Front controller](https://en.wikipedia.org/wiki/Front_controller) |                        J2EE Patterns                         | The pattern relates to the design of Web applications. It provides a centralized entry point for handling requests. |
|                                                              | [Marker](https://en.wikipedia.org/wiki/Marker_interface_pattern) |                                                              | Empty interface to associate metadata with a class.          |
|                                                              | [Module](https://en.wikipedia.org/wiki/Module_pattern)       |                                                              | Group several related elements, such as classes, singletons, methods, globally used, into a single conceptual entity. |
|                                                              | [Twin](https://en.wikipedia.org/wiki/Twin_pattern)           |                                                              | Twin allows modeling of multiple inheritance in programming languages that do not support this feature. |
|                   Behavioral Pattern（11）                   | [Observer](https://en.wikipedia.org/wiki/Observer_pattern) or [Publish/subscribe](https://en.wikipedia.org/wiki/Publish/subscribe) |                            ★★★★★                             | Define a one-to-many dependency between objects where a state change in  one object results in all its dependents being notified and updated  automatically. |
|                                                              | [Command](https://en.wikipedia.org/wiki/Command_pattern)     |                            ★★★★☆                             | Encapsulate a request as an object, thereby allowing for the  parameterization of clients with different requests, and the queuing or  logging of requests. It also allows for the support of undoable  operations. |
|                                                              | [Strategy](https://en.wikipedia.org/wiki/Strategy_pattern)   |                            ★★★★☆                             | Define a family of algorithms, encapsulate each one, and make them  interchangeable. Strategy lets the algorithm vary independently from  clients that use it. |
|                                                              | [Template method](https://en.wikipedia.org/wiki/Template_method_pattern) |                            ★★★☆☆                             | Define the skeleton of an algorithm in an operation, deferring some  steps to subclasses. Template method lets subclasses redefine certain  steps of an algorithm without changing the algorithm's structure. |
|                                                              | [Chain of responsibility](https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern) |                            ★★☆☆☆                             | Avoid coupling the sender of a request to its receiver by giving more  than one object a chance to handle the request. Chain the receiving  objects and pass the request along the chain until an object handles it. |
|                                                              | [Mediator](https://en.wikipedia.org/wiki/Mediator_pattern)   |                            ★★☆☆☆                             | Define an object that encapsulates how a set of objects interact. Mediator promotes [loose coupling](https://en.wikipedia.org/wiki/Loose_coupling) by keeping objects from referring to each other explicitly, and it allows their interaction to vary independently. |
|                                                              | [Memento](https://en.wikipedia.org/wiki/Memento_pattern)     |                            ★★☆☆☆                             | Without violating encapsulation, capture and externalize an object's  internal state allowing the object to be restored to this state later. |
|                                                              | [State](https://en.wikipedia.org/wiki/State_pattern)         |                            ★★☆☆☆                             | Allow an object to alter its behavior when its internal state changes. The object will appear to change its class. |
|                                                              | [Iterator](https://en.wikipedia.org/wiki/Iterator_pattern)   |                            ★☆☆☆☆                             |                                                              |
|                                                              | [Visitor](https://en.wikipedia.org/wiki/Visitor_pattern)     |                            ★☆☆☆☆                             | Represent an operation to be performed on instances of a set of classes. Visitor lets a new operation be defined without changing the classes of the elements on which it operates. |
|                                                              | [Interpreter](https://en.wikipedia.org/wiki/Interpreter_pattern) |                            ★☆☆☆☆                             | Given a language, define a representation for its grammar along with an  interpreter that uses the representation to interpret sentences in the  language. |
|                                                              | [Blackboard](https://en.wikipedia.org/wiki/Blackboard_(design_pattern)) |                                                              | [Artificial intelligence](https://en.wikipedia.org/wiki/Artificial_intelligence) pattern for combining disparate sources of data (see [blackboard system](https://en.wikipedia.org/wiki/Blackboard_system)) |
|                                                              | [Null object](https://en.wikipedia.org/wiki/Null_Object_pattern) |                                                              | Avoid null references by providing a default object.         |
|                                                              | [Servant](https://en.wikipedia.org/wiki/Design_pattern_Servant) |                                                              | Define common functionality for a group of classes. The servant pattern  is also frequently called helper class or utility class implementation  for a given set of classes. The helper classes generally have no objects hence they have all static methods that act upon different kinds of  class objects. |
|                                                              | [Specification](https://en.wikipedia.org/wiki/Specification_pattern) |                                                              | Recombinable [business logic](https://en.wikipedia.org/wiki/Business_logic) in a [Boolean](https://en.wikipedia.org/wiki/Boolean_algebra) fashion. |
|                                                              | [Fluent Interface](https://en.wikipedia.org/wiki/Fluent_interface) |                                                              | Design an API to be method chained so that it reads like a DSL. Each  method call returns a context through which the next logical method  call(s) are made available. |
| [Concurrency patterns](https://en.wikipedia.org/wiki/Concurrency_pattern) | [Active Object](https://en.wikipedia.org/wiki/Active_object) | *[POSA2](https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture)* | Decouples method execution from method invocation that reside in their  own thread of control. The goal is to introduce concurrency, by using [asynchronous method invocation](https://en.wikipedia.org/wiki/Asynchronous_method_invocation) and a [scheduler](https://en.wikipedia.org/wiki/Scheduling_(computing)) for handling requests. |
|                                                              | [Balking](https://en.wikipedia.org/wiki/Balking_pattern)     |                                                              | Only execute an action on an object when the object is in a particular state. |
|                                                              | [Binding properties](https://en.wikipedia.org/wiki/Binding_properties_pattern) |                                                              | Combining multiple observers to force properties in different objects to be synchronized or coordinated in some way. |
|                                                              | [Compute kernel](https://en.wikipedia.org/wiki/Compute_kernel) |                                                              | The same calculation many times in parallel, differing by integer  parameters used with non-branching pointer math into shared arrays, such as [GPU](https://en.wikipedia.org/wiki/GPU)-optimized [Matrix multiplication](https://en.wikipedia.org/wiki/Matrix_multiplication) or [Convolutional neural network](https://en.wikipedia.org/wiki/Convolutional_neural_network). |
|                                                              | [Double-checked locking](https://en.wikipedia.org/wiki/Double_checked_locking_pattern) | *[POSA2](https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture)* | Reduce the overhead of acquiring a lock by first testing the locking  criterion (the 'lock hint') in an unsafe manner; only if that succeeds  does the actual locking logic proceed. Can be unsafe when implemented in some language/hardware combinations. It can therefore sometimes be considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern). |
|                                                              | [Event-based asynchronous](https://en.wikipedia.org/wiki/Event-Based_Asynchronous_Pattern) |                                                              | Addresses problems with the asynchronous pattern that occur in multithreaded programs. |
|                                                              | [Guarded suspension](https://en.wikipedia.org/wiki/Guarded_suspension) |                                                              | Manages operations that require both a lock to be acquired and a  precondition to be satisfied before the operation can be executed. |
|                                                              | [Join](https://en.wikipedia.org/wiki/Join-pattern)           |                                                              | Join-pattern provides a way to write concurrent, parallel and  distributed programs by message passing. Compared to the use of threads  and locks, this is a high-level programming model. |
|                                                              | [Lock](https://en.wikipedia.org/wiki/Lock_(computer_science)) |                            PoEAA                             | One thread puts a "lock" on a resource, preventing other threads from accessing or modifying it. |
|                                                              | [Messaging design pattern (MDP)](https://en.wikipedia.org/wiki/Messaging_pattern) |                                                              | Allows the interchange of information (i.e. messages) between components and applications. |
|                                                              | [Monitor object](https://en.wikipedia.org/wiki/Monitor_(synchronization)) | *[POSA2](https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture)* | An object whose methods are subject to [mutual exclusion](https://en.wikipedia.org/wiki/Mutual_exclusion), thus preventing multiple objects from erroneously trying to use it at the same time. |
|                                                              | [Reactor](https://en.wikipedia.org/wiki/Reactor_pattern)     | *[POSA2](https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture)* | A reactor object provides an asynchronous interface to resources that must be handled synchronously. |
|                                                              | [Read-write lock](https://en.wikipedia.org/wiki/Read/write_lock_pattern) |                                                              | Allows concurrent read access to an object, but requires exclusive  access for write operations. An underlying semaphore might be used for  writing, and a [Copy-on-write](https://en.wikipedia.org/wiki/Copy-on-write) mechanism may or may not be used. |
|                                                              | [Scheduler](https://en.wikipedia.org/wiki/Scheduler_pattern) |                                                              | Explicitly control when threads may execute single-threaded code. |
|                                                              | [Thread pool](https://en.wikipedia.org/wiki/Thread_pool_pattern) |                                                              | A number of threads are created to perform a number of tasks, which are  usually organized in a queue. Typically, there are many more tasks than  threads. Can be considered a special case of the [object pool](https://en.wikipedia.org/wiki/Object_pool) pattern. |
|                                                              | [Thread-specific storage](https://en.wikipedia.org/wiki/Thread-Specific_Storage) | *[POSA2](https://en.wikipedia.org/wiki/Pattern-Oriented_Software_Architecture)* | Static or "global" memory local to a thread.                 |
|                                                              | Safe Concurrency with Exclusive Ownership                    |                                                              | Avoiding the need for runtime concurrent mechanisms, because exclusive  ownership can be proven. This is a notable capability of the Rust  language, but compile-time checking isn't the only means, a programmer  will often manually design such patterns into code - omitting the use of locking mechanism because the programmer assesses that a given variable is never going to be concurrently accessed. |
|                                                              | CPU atomic operation                                         |                                                              | x86 and other CPU architectures support a range of atomic instructions  that guarantee memory safety for modifying and accessing primitive  values (integers). For example, two threads may both increment a counter safely. These capabilities can also be used to implement the mechanisms for other concurrency patterns as above. The [C#](https://en.wikipedia.org/wiki/C_Sharp_(programming_language)) language uses the [Interlocked](https://docs.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-5.0) class for these capabilities. |



# DesignPrinciple

> The ultimate goal of all principles: High cohesion, loose coupling



| Class                                     |                  Name                   | Stars | Definition                                                   |
| ----------------------------------------- | :-------------------------------------: | :---: | ------------------------------------------------------------ |
| SOLID(5) principles for class             |  Single Responsibility Principle, SRP   | ★★★★☆ | A class should have one, and only one, reason to change.   |
|                                           |       Open-Closed Principle, OCP        | ★★★★★ | *You should be able to extend a classes behavior, without modifying it* |
|                                           |   Liskov Substitution Principle, LSP    | ★★★★★ | *Derived classes must be substitutable for their base classes.* |
|                                           |  Interface Segregation Principle, ISP   | ★★☆☆☆ | *Make fine grained interfaces that are client specific.*     |
|                                           |  Dependence  Inversion Principle, DIP   | ★★★★★ | *Depend on abstractions, not on concretions.*                |
| [6] principles for packages (3)*cohesion* |     Composite Reuse Principle, CRP      | ★★★★☆ | *Classes that are used together are packaged together.*      |
|                                           |      The Common Closure Principle       |       | *Classes that change together are packaged together.*        |
|                                           | The Release Reuse Equivalency Principle |       | *The granule of reuse is the granule of release.*            |
| (3) couplings & metrics                   |   The Acyclic Dependencies Principle    |       | *The dependency graph of packages must have no cycles.*      |
|                                           |    The Stable Dependencies Principle    |       | *Depend in the direction of stability.*                      |
|                                           |    The Stable Abstractions Principle    |       | *Abstractness increases with stability.*                     |
| (1)                                       |           Law of Demeter, LoD           | ★★★☆☆ | Each unit should have only limited knowledge about other units: only units "closely" related to the current unit. (Black box) |
